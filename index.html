<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ASCII Art Converter</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/topojson-client@3"></script>
  <style>
    @font-face {
      font-family: 'GeistMono-Light';
      src: url('./assets/GeistMono-Light.woff2') format('woff2');
      font-weight: 300;
      font-style: normal;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'GeistMono-Light', monospace, system-ui, sans-serif;
      background: #0a0a0a;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .header {
      padding: 20px;
      text-align: center;
      border-bottom: 1px solid #222;
    }

    .header h1 {
      font-size: 1.5rem;
      font-weight: 300;
      letter-spacing: 0.1em;
      margin-bottom: 8px;
    }

    .header p {
      font-size: 0.85rem;
      color: #888;
    }

    .main-container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .controls-panel {
      width: 320px;
      background: #111;
      border-right: 1px solid #222;
      padding: 20px;
      overflow-y: auto;
      flex-shrink: 0;
    }

    .canvas-panel {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      position: relative;
      overflow: auto;
    }

    .upload-zone {
      border: 2px dashed #333;
      border-radius: 8px;
      padding: 30px;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.2s, background 0.2s;
      margin-bottom: 20px;
    }

    .upload-zone:hover {
      border-color: #555;
      background: #1a1a1a;
    }

    .upload-zone.dragover {
      border-color: #888;
      background: #1f1f1f;
    }

    .upload-zone input {
      display: none;
    }

    .upload-icon {
      font-size: 2rem;
      margin-bottom: 10px;
      opacity: 0.5;
    }

    .upload-text {
      font-size: 0.9rem;
      color: #888;
    }

    .control-group {
      margin-bottom: 20px;
    }

    .control-group label {
      display: block;
      font-size: 0.8rem;
      color: #888;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .control-group input[type="range"] {
      width: 100%;
      height: 4px;
      background: #333;
      border-radius: 2px;
      appearance: none;
      cursor: pointer;
    }

    .control-group input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 14px;
      height: 14px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
    }

    .control-group input[type="text"],
    .control-group select {
      width: 100%;
      padding: 8px 12px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 4px;
      color: #e0e0e0;
      font-family: inherit;
      font-size: 0.9rem;
    }

    .control-group select {
      cursor: pointer;
    }

    .control-value {
      float: right;
      font-size: 0.8rem;
      color: #666;
    }

    .canvas-container {
      position: relative;
      background: #000;
      border-radius: 4px;
      overflow: hidden;
      /* Size will be set dynamically based on source aspect ratio */
    }

    .ascii-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    .video-container {
      position: absolute;
      width: 1px;
      height: 1px;
      overflow: hidden;
      opacity: 0;
      pointer-events: none;
    }

    .placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #444;
      text-align: center;
      padding: 40px;
    }

    .placeholder-icon {
      font-size: 4rem;
      margin-bottom: 20px;
      opacity: 0.3;
    }

    .placeholder-text {
      font-size: 1rem;
      color: #555;
    }

    .btn {
      padding: 10px 20px;
      background: #222;
      border: 1px solid #333;
      border-radius: 4px;
      color: #e0e0e0;
      font-family: inherit;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background 0.2s;
      width: 100%;
      margin-top: 10px;
    }

    .btn:hover {
      background: #333;
    }

    .btn-primary {
      background: #1a3a1a;
      border-color: #2a5a2a;
    }

    .btn-primary:hover {
      background: #2a5a2a;
    }

    .section-title {
      font-size: 0.75rem;
      color: #555;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 15px;
      padding-bottom: 8px;
      border-bottom: 1px solid #222;
    }

    .presets {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 20px;
    }

    .preset-btn {
      padding: 8px 12px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 4px;
      color: #888;
      font-family: inherit;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .preset-btn:hover {
      background: #222;
      color: #e0e0e0;
    }

    .preset-btn.active {
      background: #2a2a2a;
      border-color: #444;
      color: #e0e0e0;
    }

    @media (max-width: 900px) {
      .main-container {
        flex-direction: column;
      }

      .controls-panel {
        width: 100%;
        max-height: 300px;
        border-right: none;
        border-bottom: 1px solid #222;
      }

      .canvas-panel {
        min-height: 400px;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>ASCII ART CONVERTER</h1>
    <p>Transform images and videos into ASCII art</p>
  </div>

  <div class="main-container">
    <div class="controls-panel">
      <div class="upload-zone" id="uploadZone">
        <div class="upload-icon">+</div>
        <div class="upload-text">Drop image or video here<br>or click to browse</div>
        <input type="file" id="fileInput" accept="image/*,video/*">
      </div>

      <button class="btn" id="globeBtn" style="margin-bottom: 20px;">üåç Use Globe</button>

      <div class="section-title">Presets</div>
      <div class="presets">
        <button class="preset-btn active" data-preset="default">Default</button>
        <button class="preset-btn" data-preset="high-contrast">High Contrast</button>
        <button class="preset-btn" data-preset="minimal">Minimal</button>
        <button class="preset-btn" data-preset="dense">Dense</button>
      </div>

      <div class="section-title">Grid Settings</div>

      <div class="control-group">
        <label>Cell Size <span class="control-value" id="cellSizeValue">12</span></label>
        <input type="range" id="cellSize" min="6" max="30" value="12">
      </div>

      <div class="control-group">
        <label>Character Density</label>
        <input type="text" id="density" value="$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,&quot;^`'. ">
      </div>

      <div class="section-title">Appearance</div>

      <div class="control-group">
        <label>Gamma <span class="control-value" id="gammaValue">1.6</span></label>
        <input type="range" id="gamma" min="0.5" max="3" step="0.1" value="1.6">
      </div>

      <div class="control-group">
        <label>Tile Opacity <span class="control-value" id="tileOpacityValue">0.5</span></label>
        <input type="range" id="tileOpacity" min="0" max="1" step="0.05" value="0.5">
      </div>

      <div class="control-group">
        <label>Glyph Opacity <span class="control-value" id="glyphOpacityValue">1.0</span></label>
        <input type="range" id="glyphOpacity" min="0" max="1" step="0.05" value="1">
      </div>

      <div class="control-group">
        <label>Blend Mode</label>
        <select id="blendMode">
          <option value="0">Screen</option>
          <option value="1" selected>Add</option>
          <option value="2">Color Dodge</option>
          <option value="3">Normal</option>
        </select>
      </div>

      <div class="control-group">
        <label>Blend Strength <span class="control-value" id="blendStrengthValue">1.0</span></label>
        <input type="range" id="blendStrength" min="0" max="1" step="0.05" value="1">
      </div>

      <button class="btn btn-primary" id="downloadBtn">Download Image</button>
      <button class="btn" id="recordBtn" style="display: none;">‚è∫ Start Recording</button>
      <button class="btn" id="stopRecordBtn" style="display: none;">‚èπ Stop & Download</button>
      <div id="recordingStatus" style="display: none; margin-top: 10px; padding: 8px; background: #2a1a1a; border: 1px solid #5a2a2a; border-radius: 4px; font-size: 0.8rem; color: #ff6b6b; text-align: center;">
        ‚è∫ Recording...
      </div>
    </div>

    <div class="canvas-panel">
      <div class="canvas-container" id="canvasContainer">
        <div class="video-container">
          <video id="sourceVideo" muted playsinline loop crossorigin="anonymous"></video>
        </div>
        <div class="video-container" id="globeContainer" style="width: 512px; height: 512px;">
          <canvas id="globeCanvas"></canvas>
        </div>
        <canvas id="asciiCanvas" class="ascii-canvas"></canvas>
        <div class="placeholder" id="placeholder">
          <div class="placeholder-icon">‚óà</div>
          <div class="placeholder-text">Upload an image or video to begin</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ASCII Art Renderer - Simplified standalone version
    class ASCIIRenderer {
      static getDefaults() {
        return {
          cellSizePx: 12,
          cellAspectRatio: 0.6,
          maxCanvasBackingDimPx: 4096,
          charAspectRatio: 0.85,
          charFillRatio: 1,
          density: String.raw`$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,"^'. `,
          atlasGlyphSize: 50,
          fontFamily: "'GeistMono-Light', monospace, system-ui, sans-serif",
          atlasPaddingPx: 2,
          atlasPaddingPxPerCell: 120,
          tileOpacity: 0.5,
          glyphOpacity: 1.0,
          gamma: 1.6,
          edgeLo: 0.0,
          edgeHi: 1.0,
          blendMode: 1,
          blendStrength: 1,
          preserveHue: 1,
          dprCap: 2,
        };
      }

      constructor(containerId, canvasId, videoId, config = {}) {
        const defaults = ASCIIRenderer.getDefaults();
        this.config = { ...defaults, ...config };

        this.container = document.getElementById(containerId);
        this.canvas = document.getElementById(canvasId);
        this.video = document.getElementById(videoId);

        this.cols = 50;
        this.rows = 25;
        this.actualCellSize = this.config.cellSizePx;

        this.gl = null;
        this.prog = null;
        this.locs = null;
        this.atlas = null;
        this.videoTex = null;
        this._videoW = 0;
        this._videoH = 0;
        this._resourcesReady = false;
        this._rafId = null;
        this._isVideo = false;
        this._sourceReady = false;

        this.dpr = Math.max(1, Math.min(this.config.dprCap, window.devicePixelRatio || 1));

        if (!this.container || !this.canvas || !this.video) {
          console.error('Missing elements');
          return;
        }

        this._initPipeline();
      }

      async _initPipeline() {
        try {
          this._initGL();
          this._setupShaders();
          this._setupGeometry();
          this._setupTextures();
          this._updateGridDimensions();
          this._setupUniforms();
          this._buildAtlas();
          this._resourcesReady = true;

          window.addEventListener('resize', () => this._handleResize(), { passive: true });
          this._handleResize();
        } catch (e) {
          console.error('Init error', e);
        }
      }

      _initGL() {
        this.gl = this.canvas.getContext('webgl', { alpha: false, antialias: false, preserveDrawingBuffer: true });
        if (!this.gl) throw new Error('WebGL not supported');
      }

      _setupShaders() {
        const vsSrc = `
          attribute vec2 aPos;
          attribute vec2 aUV;
          varying vec2 vUV;
          void main() {
            vUV = aUV;
            gl_Position = vec4(aPos, 0.0, 1.0);
          }
        `;

        const fsSrc = `
          precision mediump float;
          varying vec2 vUV;
          uniform sampler2D uVideo;
          uniform sampler2D uAtlas;
          uniform vec2  uCanvasSize;
          uniform float uCols;
          uniform float uRows;
          uniform vec2  uInvGrid;
          uniform vec2  uCellSizePx;
          uniform float uCharAspectRatio;
          uniform float uCharFillRatio;
          uniform float uGamma;
          uniform float uEdgeLo;
          uniform float uEdgeHi;
          uniform float uTileOpacity;
          uniform float uGlyphOpacity;
          uniform int   uBlendMode;
          uniform float uBlendStrength;
          uniform int   uPreserveHue;
          uniform float uGlyphCount;
          uniform vec2  uAtlasGrid;
          uniform vec2  uAtlasPadding;
          uniform vec2  uCropMin;
          uniform vec2  uCropMax;

          float luminance(vec3 rgb){ return dot(rgb, vec3(0.299,0.587,0.114)); }
          float applyGamma(float x,float g){ return pow(clamp(x,0.0,1.0),g); }

          vec3 blendScreen(vec3 b, vec3 t){ return 1.0 - (1.0-b)*(1.0-t); }
          vec3 blendAdd(vec3 b, vec3 t){ return clamp(b+t,0.0,1.0); }
          vec3 blendColorDodge(vec3 b, vec3 t){ vec3 d = max(vec3(0.001), 1.0 - t); return clamp(b / d, 0.0, 1.0); }
          vec3 doBlend(vec3 b, vec3 t, int m){
            if(m==1) return blendAdd(b,t);
            if(m==2) return blendColorDodge(b,t);
            if(m==3) return t;
            return blendScreen(b,t);
          }

          vec3 retintToBase(vec3 c, vec3 base){
            float bl = max(0.0001, luminance(base));
            float cl = max(0.0001, luminance(c));
            return clamp(base * (cl/bl), 0.0, 1.0);
          }

          void main(){
            vec2 grid = vec2(uCols, uRows);
            vec2 cellCoord = floor(vUV * grid);
            vec2 cellUV = fract(vUV * grid);
            vec2 tileCenterUV = (cellCoord + 0.5) * uInvGrid;

            vec2 uvVideo = mix(uCropMin, uCropMax, tileCenterUV);
            vec3 videoRGB = texture2D(uVideo, uvVideo).rgb;

            float lum = applyGamma(dot(videoRGB, vec3(0.299,0.587,0.114)), uGamma);
            float glyphIdx = floor(lum * (uGlyphCount - 1.0) + 0.5);

            float charH = uCellSizePx.y * uCharFillRatio;
            float charW = charH * uCharAspectRatio;
            vec2 charSizeInCell = vec2(charW / uCellSizePx.x, charH / uCellSizePx.y);
            vec2 charStart = (1.0 - charSizeInCell) * 0.5;
            vec2 charEnd = charStart + charSizeInCell;

            float charMask = 1.0;
            if(cellUV.x < charStart.x || cellUV.x > charEnd.x || cellUV.y < charStart.y || cellUV.y > charEnd.y){
              charMask = 0.0;
            }

            vec2 charUV = (cellUV - charStart) / charSizeInCell;
            charUV = clamp(charUV, 0.0, 1.0);

            float aCols = uAtlasGrid.x;
            float ax = mod(glyphIdx, aCols);
            float ay = floor(glyphIdx / aCols);

            vec2 paddedUV = uAtlasPadding + charUV * (1.0 - 2.0 * uAtlasPadding);
            vec2 atlasUV = (vec2(ax, ay) + paddedUV) / uAtlasGrid;

            float glyphAlpha = texture2D(uAtlas, atlasUV).r;
            glyphAlpha = smoothstep(uEdgeLo, uEdgeHi, glyphAlpha);
            glyphAlpha *= charMask * uGlyphOpacity;

            vec3 baseRGB = mix(vec3(0.0), videoRGB, clamp(uTileOpacity, 0.0, 1.0));
            vec3 glyphRGB = videoRGB;
            vec3 blended = doBlend(baseRGB, glyphRGB, uBlendMode);
            if(uBlendMode != 3) blended = mix(baseRGB, blended, clamp(uBlendStrength, 0.0, 1.0));
            if(uPreserveHue == 1) blended = retintToBase(blended, baseRGB);
            vec3 finalRGB = mix(baseRGB, blended, glyphAlpha);

            gl_FragColor = vec4(finalRGB, 1.0);
          }
        `;

        this.prog = this._createProgram(vsSrc, fsSrc);
        this.locs = this._getUniformLocations([
          'uVideo', 'uAtlas', 'uCanvasSize', 'uCols', 'uRows', 'uInvGrid',
          'uCellSizePx', 'uCharAspectRatio', 'uCharFillRatio', 'uGamma',
          'uEdgeLo', 'uEdgeHi', 'uTileOpacity', 'uGlyphOpacity', 'uBlendMode',
          'uBlendStrength', 'uPreserveHue', 'uGlyphCount', 'uAtlasGrid',
          'uAtlasPadding', 'uCropMin', 'uCropMax'
        ]);
      }

      _setupGeometry() {
        const gl = this.gl;
        const vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
          -1, -1, 0, 0,  1, -1, 1, 0,  -1, 1, 0, 1,
          -1, 1, 0, 1,   1, -1, 1, 0,   1, 1, 1, 1,
        ]), gl.STATIC_DRAW);

        const aPos = gl.getAttribLocation(this.prog, 'aPos');
        const aUV = gl.getAttribLocation(this.prog, 'aUV');
        gl.enableVertexAttribArray(aPos);
        gl.enableVertexAttribArray(aUV);
        gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 16, 0);
        gl.vertexAttribPointer(aUV, 2, gl.FLOAT, false, 16, 8);
      }

      _setupTextures() {
        const gl = this.gl;
        this.videoTex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.videoTex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        const black = new Uint8Array([0, 0, 0, 255]);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, black);
      }

      _setupUniforms() {
        const gl = this.gl;
        gl.useProgram(this.prog);
        gl.uniform1i(this.locs.uVideo, 0);
        gl.uniform1i(this.locs.uAtlas, 1);
        gl.uniform2f(this.locs.uCanvasSize, this.canvas.width, this.canvas.height);
        this._applyGridUniforms();

        gl.uniform1f(this.locs.uCharAspectRatio, this.config.charAspectRatio);
        gl.uniform1f(this.locs.uCharFillRatio, this.config.charFillRatio);
        gl.uniform1f(this.locs.uGamma, this.config.gamma);
        gl.uniform1f(this.locs.uEdgeLo, this.config.edgeLo);
        gl.uniform1f(this.locs.uEdgeHi, this.config.edgeHi);
        gl.uniform1f(this.locs.uTileOpacity, this.config.tileOpacity);
        gl.uniform1f(this.locs.uGlyphOpacity, this.config.glyphOpacity);
        gl.uniform1i(this.locs.uBlendMode, this.config.blendMode | 0);
        gl.uniform1f(this.locs.uBlendStrength, this.config.blendStrength);
        gl.uniform1i(this.locs.uPreserveHue, this.config.preserveHue ? 1 : 0);
        gl.uniform1f(this.locs.uGlyphCount, this.config.density.length);

        gl.uniform2f(this.locs.uCropMin, 0, 0);
        gl.uniform2f(this.locs.uCropMax, 1, 1);
      }

      _buildAtlas() {
        const count = this.config.density.length;
        const gridCols = Math.ceil(Math.sqrt(count));
        const gridRows = Math.ceil(count / gridCols);
        const atlasW = gridCols * this.config.atlasGlyphSize;
        const atlasH = gridRows * this.config.atlasGlyphSize;

        const c = document.createElement('canvas');
        c.width = atlasW;
        c.height = atlasH;
        const ctx = c.getContext('2d', { alpha: false });
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, atlasW, atlasH);
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = `${Math.floor(this.config.atlasGlyphSize * 0.8)}px ${this.config.fontFamily}`;

        for (let i = 0; i < count; i++) {
          const ch = this.config.density[i];
          const gx = i % gridCols;
          const gy = Math.floor(i / gridCols);
          const cx = gx * this.config.atlasGlyphSize + this.config.atlasGlyphSize * 0.5;
          const cy = gy * this.config.atlasGlyphSize + this.config.atlasGlyphSize * 0.5;
          ctx.fillText(ch, cx, cy);
        }

        const gl = this.gl;
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, c);

        this.atlas = { tex, gridCols, gridRows };

        gl.useProgram(this.prog);
        gl.uniform2f(this.locs.uAtlasGrid, gridCols, gridRows);
        const pad = this.config.atlasPaddingPx / this.config.atlasPaddingPxPerCell;
        gl.uniform2f(this.locs.uAtlasPadding, pad, pad);
      }

      _calculateGridDimensions() {
        const canvasW = this.canvas.width;
        const canvasH = this.canvas.height;
        const targetCellDevPx = Math.max(1, this.config.cellSizePx * this.dpr);

        const cols = Math.max(10, Math.floor(canvasW / targetCellDevPx));
        const ar = Math.max(0.0001, this.config.cellAspectRatio);
        const cellW = canvasW / cols;
        const cellH = cellW / ar;
        const rows = Math.max(5, Math.floor(canvasH / cellH));

        return { cols, rows, actualCellSize: cellW };
      }

      _applyGridUniforms() {
        const gl = this.gl;
        gl.useProgram(this.prog);
        gl.uniform1f(this.locs.uCols, this.cols);
        gl.uniform1f(this.locs.uRows, this.rows);
        gl.uniform2f(this.locs.uInvGrid, 1 / this.cols, 1 / this.rows);
        const cellW = Math.max(1, this.canvas.width / this.cols);
        const cellH = Math.max(1, this.canvas.height / this.rows);
        gl.uniform2f(this.locs.uCellSizePx, cellW, cellH);
        gl.uniform2f(this.locs.uCanvasSize, this.canvas.width, this.canvas.height);
      }

      _updateGridDimensions() {
        const { cols, rows, actualCellSize } = this._calculateGridDimensions();
        this.cols = cols;
        this.rows = rows;
        this.actualCellSize = actualCellSize;
        this._applyGridUniforms();
      }

      _handleResize() {
        const rect = this.container.getBoundingClientRect();
        const cssW = Math.max(2, rect.width);
        const cssH = Math.max(2, rect.height);

        let desiredW = Math.floor(cssW * this.dpr);
        let desiredH = Math.floor(cssH * this.dpr);

        const maxDim = this.config.maxCanvasBackingDimPx;
        if (desiredW > maxDim || desiredH > maxDim) {
          const s = maxDim / Math.max(desiredW, desiredH);
          desiredW = Math.floor(desiredW * s);
          desiredH = Math.floor(desiredH * s);
        }

        if (this.canvas.width !== desiredW || this.canvas.height !== desiredH) {
          this.canvas.width = desiredW;
          this.canvas.height = desiredH;
          this.gl.viewport(0, 0, desiredW, desiredH);
        }

        this._updateGridDimensions();
        this._updateCropUniforms();

        if (this._sourceReady) {
          this._drawFrame();
        }
      }

      _computeCoverCropUV() {
        const srcW = this._videoW || 1;
        const srcH = this._videoH || 1;
        const srcAR = srcW / srcH;

        const tgtW = this.canvas.width || 1;
        const tgtH = this.canvas.height || 1;
        const tgtAR = tgtW / tgtH;

        let uMin = 0, uMax = 1, vMin = 0, vMax = 1;

        if (srcAR > tgtAR) {
          const visibleW = tgtAR / srcAR;
          const offset = (1 - visibleW) * 0.5;
          uMin = offset;
          uMax = offset + visibleW;
        } else if (srcAR < tgtAR) {
          const visibleH = srcAR / tgtAR;
          const offset = (1 - visibleH) * 0.5;
          vMin = offset;
          vMax = offset + visibleH;
        }

        return { min: [uMin, vMin], max: [uMax, vMax] };
      }

      _updateCropUniforms() {
        const { min, max } = this._computeCoverCropUV();
        const gl = this.gl;
        gl.useProgram(this.prog);
        gl.uniform2f(this.locs.uCropMin, min[0], min[1]);
        gl.uniform2f(this.locs.uCropMax, max[0], max[1]);
      }

      // Disable cropping - show full source (for high-quality export)
      disableCrop() {
        const gl = this.gl;
        gl.useProgram(this.prog);
        gl.uniform2f(this.locs.uCropMin, 0, 0);
        gl.uniform2f(this.locs.uCropMax, 1, 1);
      }

      // Re-enable normal crop behavior
      enableCrop() {
        this._updateCropUniforms();
      }

      _createProgram(vs, fs) {
        const gl = this.gl;
        const v = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(v, vs);
        gl.compileShader(v);
        if (!gl.getShaderParameter(v, gl.COMPILE_STATUS)) {
          throw new Error('Vertex shader: ' + gl.getShaderInfoLog(v));
        }

        const f = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(f, fs);
        gl.compileShader(f);
        if (!gl.getShaderParameter(f, gl.COMPILE_STATUS)) {
          throw new Error('Fragment shader: ' + gl.getShaderInfoLog(f));
        }

        const p = gl.createProgram();
        gl.attachShader(p, v);
        gl.attachShader(p, f);
        gl.linkProgram(p);
        if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
          throw new Error('Program link: ' + gl.getProgramInfoLog(p));
        }
        return p;
      }

      _getUniformLocations(names) {
        const locs = {};
        for (const n of names) locs[n] = this.gl.getUniformLocation(this.prog, n);
        return locs;
      }

      loadImage(img) {
        this._isVideo = false;
        this._sourceReady = true;
        this._videoW = img.naturalWidth || img.width;
        this._videoH = img.naturalHeight || img.height;

        const gl = this.gl;
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.videoTex);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);

        this._updateCropUniforms();
        this._drawFrame();
      }

      loadVideo() {
        this._isVideo = true;
        this._sourceReady = true;
        this._videoW = this.video.videoWidth;
        this._videoH = this.video.videoHeight;
        this._updateCropUniforms();
        this._startLoop();
      }

      _startLoop() {
        if (this._rafId) cancelAnimationFrame(this._rafId);

        const loop = () => {
          if (!this._isVideo || !this._sourceReady) return;
          this._uploadVideoFrame();
          this._drawFrame();
          this._rafId = requestAnimationFrame(loop);
        };
        this._rafId = requestAnimationFrame(loop);
      }

      stopLoop() {
        if (this._rafId) {
          cancelAnimationFrame(this._rafId);
          this._rafId = null;
        }
      }

      _uploadVideoFrame() {
        const gl = this.gl;
        const vW = this.video.videoWidth;
        const vH = this.video.videoHeight;

        if (vW > 0 && vH > 0) {
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, this.videoTex);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          try {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
          } catch {}

          if (vW !== this._videoW || vH !== this._videoH) {
            this._videoW = vW;
            this._videoH = vH;
            this._updateCropUniforms();
          }
        }
      }

      _drawFrame() {
        if (!this._resourcesReady || !this._sourceReady) return;

        const gl = this.gl;
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, this.atlas.tex);

        gl.useProgram(this.prog);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }

      pushUniforms() {
        const gl = this.gl;
        gl.useProgram(this.prog);
        gl.uniform1f(this.locs.uCharAspectRatio, this.config.charAspectRatio);
        gl.uniform1f(this.locs.uCharFillRatio, this.config.charFillRatio);
        gl.uniform1f(this.locs.uGamma, this.config.gamma);
        gl.uniform1f(this.locs.uEdgeLo, this.config.edgeLo);
        gl.uniform1f(this.locs.uEdgeHi, this.config.edgeHi);
        gl.uniform1f(this.locs.uTileOpacity, this.config.tileOpacity);
        gl.uniform1f(this.locs.uGlyphOpacity, this.config.glyphOpacity);
        gl.uniform1i(this.locs.uBlendMode, this.config.blendMode | 0);
        gl.uniform1f(this.locs.uBlendStrength, this.config.blendStrength);
        gl.uniform1i(this.locs.uPreserveHue, this.config.preserveHue ? 1 : 0);
        gl.uniform1f(this.locs.uGlyphCount, this.config.density.length);

        if (!this._isVideo && this._sourceReady) {
          this._drawFrame();
        }
      }

      rebuildAtlas() {
        if (this.atlas && this.atlas.tex) {
          this.gl.deleteTexture(this.atlas.tex);
        }
        this._buildAtlas();
        this.pushUniforms();
      }

      updateCellSize(size) {
        this.config.cellSizePx = size;
        this._updateGridDimensions();
        if (!this._isVideo && this._sourceReady) {
          this._drawFrame();
        }
      }
    }

    // Globe Scene for ASCII effect
    class GlobeScene {
      constructor(canvas) {
        this.canvas = canvas;
        this.radius = 1.5;
        this.clock = new THREE.Clock();

        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000000);

        this.camera = new THREE.PerspectiveCamera(70, 1, 1, 1000);
        this.camera.position.z = 3;

        this.renderer = new THREE.WebGLRenderer({
          canvas,
          antialias: true,
          preserveDrawingBuffer: true,
        });
        this.renderer.setSize(512, 512);
        this.renderer.setPixelRatio(1);

        this.particles = null;
        this.isReady = false;
        this.animating = false;

        this.initLandParticles();
      }

      async initLandParticles() {
        try {
          const response = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@1/world/50m.json');
          const worldData = await response.json();
          const land = topojson.feature(worldData, worldData.objects.land);

          const positions = [];
          const colors = [];
          const landColor = new THREE.Color(0x444444);

          let allCoordinates = [];
          if (land.type === 'FeatureCollection') {
            for (const feature of land.features) {
              if (feature.geometry.type === 'Polygon') {
                allCoordinates.push(...feature.geometry.coordinates);
              } else if (feature.geometry.type === 'MultiPolygon') {
                allCoordinates.push(...feature.geometry.coordinates.flat());
              }
            }
          } else if (land.geometry) {
            if (land.geometry.type === 'MultiPolygon') {
              allCoordinates = land.geometry.coordinates.flat();
            } else if (land.geometry.type === 'Polygon') {
              allCoordinates = land.geometry.coordinates;
            }
          }

          for (const polygon of allCoordinates) {
            for (let i = 0; i < polygon.length; i++) {
              const [lng, lat] = polygon[i];
              const phi = THREE.MathUtils.degToRad(lng);
              const theta = THREE.MathUtils.degToRad(lat);

              const x = this.radius * Math.cos(theta) * Math.cos(phi);
              const y = this.radius * Math.sin(theta);
              const z = -this.radius * Math.cos(theta) * Math.sin(phi);

              positions.push(x, y, z);
              colors.push(landColor.r, landColor.g, landColor.b);
            }
          }

          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
          geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

          this.particles = new THREE.Points(
            geometry,
            new THREE.PointsMaterial({
              vertexColors: true,
              size: 0.008,
              sizeAttenuation: true,
            })
          );

          this.scene.add(this.particles);
          this.isReady = true;
        } catch (error) {
          console.error('Failed to load globe data:', error);
        }
      }

      start() {
        this.animating = true;
        this.animate();
      }

      stop() {
        this.animating = false;
      }

      animate = () => {
        if (!this.animating) return;
        requestAnimationFrame(this.animate);

        if (this.particles) {
          this.particles.rotation.y += 0.003;
        }

        this.renderer.render(this.scene, this.camera);
      }

      dispose() {
        this.animating = false;
        if (this.particles) {
          this.scene.remove(this.particles);
          this.particles.geometry.dispose();
          this.particles.material.dispose();
        }
        this.renderer.dispose();
      }
    }

    // UI Controller
    class ASCIIToolUI {
      constructor() {
        this.renderer = null;
        this.currentFile = null;
        this.isVideo = false;
        this.isGlobe = false;

        // Recording state
        this.mediaRecorder = null;
        this.recordedChunks = [];
        this.isRecording = false;

        // Globe state
        this.globeScene = null;
        this.globeRafId = null;

        this.uploadZone = document.getElementById('uploadZone');
        this.fileInput = document.getElementById('fileInput');
        this.placeholder = document.getElementById('placeholder');
        this.video = document.getElementById('sourceVideo');
        this.recordBtn = document.getElementById('recordBtn');
        this.stopRecordBtn = document.getElementById('stopRecordBtn');
        this.recordingStatus = document.getElementById('recordingStatus');
        this.globeBtn = document.getElementById('globeBtn');
        this.globeCanvas = document.getElementById('globeCanvas');

        this.controls = {
          cellSize: document.getElementById('cellSize'),
          density: document.getElementById('density'),
          gamma: document.getElementById('gamma'),
          tileOpacity: document.getElementById('tileOpacity'),
          glyphOpacity: document.getElementById('glyphOpacity'),
          blendMode: document.getElementById('blendMode'),
          blendStrength: document.getElementById('blendStrength'),
        };

        this.presets = {
          default: {
            cellSize: 12, gamma: 1.6, tileOpacity: 0.5, glyphOpacity: 1,
            blendMode: 1, blendStrength: 1,
            density: String.raw`$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,"^'. `
          },
          'high-contrast': {
            cellSize: 10, gamma: 2.2, tileOpacity: 0.3, glyphOpacity: 1,
            blendMode: 2, blendStrength: 1,
            density: '@%#*+=-:. '
          },
          minimal: {
            cellSize: 16, gamma: 1.4, tileOpacity: 0.6, glyphOpacity: 0.9,
            blendMode: 0, blendStrength: 0.8,
            density: '#=-. '
          },
          dense: {
            cellSize: 8, gamma: 1.8, tileOpacity: 0.4, glyphOpacity: 1,
            blendMode: 1, blendStrength: 1,
            density: String.raw`$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,"^'. `
          }
        };

        this._setupEventListeners();
        this._initRenderer();
      }

      _initRenderer() {
        this.renderer = new ASCIIRenderer('canvasContainer', 'asciiCanvas', 'sourceVideo');

        // Set default container size for placeholder
        const container = document.getElementById('canvasContainer');
        container.style.width = '640px';
        container.style.height = '480px';

        // Track source dimensions for window resize
        this.sourceWidth = 640;
        this.sourceHeight = 480;

        // Recalculate on window resize
        window.addEventListener('resize', () => {
          if (this.renderer._sourceReady || this.isGlobe) {
            this._resizeContainerToSource(this.sourceWidth, this.sourceHeight);
          }
        });
      }

      _setupEventListeners() {
        // File upload
        this.uploadZone.addEventListener('click', () => this.fileInput.click());
        this.fileInput.addEventListener('change', (e) => this._handleFile(e.target.files[0]));

        // Drag and drop
        this.uploadZone.addEventListener('dragover', (e) => {
          e.preventDefault();
          this.uploadZone.classList.add('dragover');
        });
        this.uploadZone.addEventListener('dragleave', () => {
          this.uploadZone.classList.remove('dragover');
        });
        this.uploadZone.addEventListener('drop', (e) => {
          e.preventDefault();
          this.uploadZone.classList.remove('dragover');
          if (e.dataTransfer.files.length) {
            this._handleFile(e.dataTransfer.files[0]);
          }
        });

        // Controls
        this.controls.cellSize.addEventListener('input', (e) => {
          document.getElementById('cellSizeValue').textContent = e.target.value;
          this.renderer.updateCellSize(parseFloat(e.target.value));
        });

        this.controls.gamma.addEventListener('input', (e) => {
          document.getElementById('gammaValue').textContent = e.target.value;
          this.renderer.config.gamma = parseFloat(e.target.value);
          this.renderer.pushUniforms();
        });

        this.controls.tileOpacity.addEventListener('input', (e) => {
          document.getElementById('tileOpacityValue').textContent = e.target.value;
          this.renderer.config.tileOpacity = parseFloat(e.target.value);
          this.renderer.pushUniforms();
        });

        this.controls.glyphOpacity.addEventListener('input', (e) => {
          document.getElementById('glyphOpacityValue').textContent = e.target.value;
          this.renderer.config.glyphOpacity = parseFloat(e.target.value);
          this.renderer.pushUniforms();
        });

        this.controls.blendMode.addEventListener('change', (e) => {
          this.renderer.config.blendMode = parseInt(e.target.value);
          this.renderer.pushUniforms();
        });

        this.controls.blendStrength.addEventListener('input', (e) => {
          document.getElementById('blendStrengthValue').textContent = e.target.value;
          this.renderer.config.blendStrength = parseFloat(e.target.value);
          this.renderer.pushUniforms();
        });

        this.controls.density.addEventListener('change', (e) => {
          if (e.target.value.length > 0) {
            this.renderer.config.density = e.target.value;
            this.renderer.rebuildAtlas();
          }
        });

        // Presets
        document.querySelectorAll('.preset-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            this._applyPreset(btn.dataset.preset);
          });
        });

        // Download
        document.getElementById('downloadBtn').addEventListener('click', () => this._download());

        // Recording
        this.recordBtn.addEventListener('click', () => this._startRecording());
        this.stopRecordBtn.addEventListener('click', () => this._stopRecording());

        // Globe
        this.globeBtn.addEventListener('click', () => this._activateGlobe());
      }

      _activateGlobe() {
        // Stop any ongoing recording
        if (this.isRecording) {
          this._stopRecording();
        }

        // Stop video if playing
        this.renderer.stopLoop();
        this.video.pause();
        this.video.src = '';

        this.isVideo = false;
        this.isGlobe = true;

        // Initialize globe if not already
        if (!this.globeScene) {
          this.globeScene = new GlobeScene(this.globeCanvas);
        }

        // Wait for globe to be ready
        const waitForGlobe = () => {
          if (this.globeScene.isReady) {
            this.placeholder.style.display = 'none';
            this._resizeContainerToSource(512, 512); // Globe is square
            this.globeScene.start();
            this._startGlobeLoop();

            // Show record button for globe (it's animated)
            this.recordBtn.style.display = 'block';
          } else {
            setTimeout(waitForGlobe, 100);
          }
        };
        waitForGlobe();
      }

      _startGlobeLoop() {
        if (this.globeRafId) {
          cancelAnimationFrame(this.globeRafId);
        }

        const loop = () => {
          if (!this.isGlobe) return;

          // Use globe canvas as source for ASCII renderer
          this.renderer._isVideo = false;
          this.renderer._sourceReady = true;
          this.renderer._videoW = this.globeCanvas.width;
          this.renderer._videoH = this.globeCanvas.height;

          const gl = this.renderer.gl;
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, this.renderer.videoTex);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.globeCanvas);

          this.renderer._updateCropUniforms();
          this.renderer._drawFrame();

          this.globeRafId = requestAnimationFrame(loop);
        };

        this.globeRafId = requestAnimationFrame(loop);
      }

      _stopGlobeLoop() {
        if (this.globeRafId) {
          cancelAnimationFrame(this.globeRafId);
          this.globeRafId = null;
        }
        if (this.globeScene) {
          this.globeScene.stop();
        }
        this.isGlobe = false;
      }

      _resizeContainerToSource(sourceWidth, sourceHeight) {
        // Store for window resize handling
        this.sourceWidth = sourceWidth;
        this.sourceHeight = sourceHeight;

        const container = document.getElementById('canvasContainer');
        const panel = container.parentElement;
        const panelRect = panel.getBoundingClientRect();

        // Available space (with padding)
        const availableWidth = panelRect.width - 40;
        const availableHeight = panelRect.height - 40;

        const sourceAspect = sourceWidth / sourceHeight;
        const availableAspect = availableWidth / availableHeight;

        let containerWidth, containerHeight;

        if (sourceAspect > availableAspect) {
          // Source is wider than available space
          containerWidth = Math.min(sourceWidth, availableWidth);
          containerHeight = containerWidth / sourceAspect;
        } else {
          // Source is taller than available space
          containerHeight = Math.min(sourceHeight, availableHeight);
          containerWidth = containerHeight * sourceAspect;
        }

        // Ensure minimum size
        containerWidth = Math.max(200, containerWidth);
        containerHeight = Math.max(150, containerHeight);

        container.style.width = `${containerWidth}px`;
        container.style.height = `${containerHeight}px`;

        // Trigger resize on the renderer
        if (this.renderer) {
          this.renderer._handleResize();
        }
      }

      _startRecording() {
        const canvas = document.getElementById('asciiCanvas');

        // Get current canvas dimensions for filename
        this._recordingWidth = canvas.width;
        this._recordingHeight = canvas.height;

        // Get canvas stream at 60fps for smoother output
        const stream = canvas.captureStream(60);

        // Try different codecs for better compatibility
        const mimeTypes = [
          'video/webm;codecs=vp9',
          'video/webm;codecs=vp8',
          'video/webm',
          'video/mp4'
        ];

        let selectedMimeType = '';
        for (const mimeType of mimeTypes) {
          if (MediaRecorder.isTypeSupported(mimeType)) {
            selectedMimeType = mimeType;
            break;
          }
        }

        if (!selectedMimeType) {
          alert('Video recording is not supported in this browser');
          return;
        }

        this.recordedChunks = [];
        this.mediaRecorder = new MediaRecorder(stream, {
          mimeType: selectedMimeType,
          videoBitsPerSecond: 50000000 // 50 Mbps for high quality
        });

        this.mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) {
            this.recordedChunks.push(e.data);
          }
        };

        this.mediaRecorder.onstop = () => {
          this._downloadRecording();
        };

        // Start recording
        this.mediaRecorder.start(100); // Collect data every 100ms
        this.isRecording = true;

        // For video sources, restart from beginning and auto-stop at end
        if (this.isVideo && !this.isGlobe) {
          this.video.currentTime = 0;
          this.video.play();

          // Auto-stop when video ends
          this._onVideoEnded = () => {
            if (this.isRecording) {
              this._stopRecording();
            }
          };
          this.video.addEventListener('ended', this._onVideoEnded);
        }
        // For globe, user must manually stop recording

        // Update UI
        this.recordBtn.style.display = 'none';
        this.stopRecordBtn.style.display = 'block';
        this.recordingStatus.style.display = 'block';
        this.recordingStatus.innerHTML = `‚è∫ Recording ${this._recordingWidth}x${this._recordingHeight} @ 60fps`;
      }

      _stopRecording() {
        if (this.mediaRecorder && this.isRecording) {
          this.mediaRecorder.stop();
          this.isRecording = false;

          // Remove video ended listener
          if (this._onVideoEnded) {
            this.video.removeEventListener('ended', this._onVideoEnded);
            this._onVideoEnded = null;
          }

          // Update UI
          this.recordBtn.style.display = 'block';
          this.stopRecordBtn.style.display = 'none';
          this.recordingStatus.style.display = 'none';
          this.recordingStatus.innerHTML = '‚è∫ Recording...'; // Reset for next time
        }
      }

      _downloadRecording() {
        const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        const resolution = this._recordingHeight >= 1080 ? '1080p' :
                          this._recordingHeight >= 720 ? '720p' :
                          `${this._recordingHeight}p`;
        link.download = `ascii-art-${resolution}-${this._recordingWidth}x${this._recordingHeight}.webm`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
      }

      _handleFile(file) {
        if (!file) return;

        // Stop any ongoing recording
        if (this.isRecording) {
          this._stopRecording();
        }

        // Stop globe if running
        if (this.isGlobe) {
          this._stopGlobeLoop();
        }

        this.currentFile = file;
        const url = URL.createObjectURL(file);

        if (file.type.startsWith('image/')) {
          this.isVideo = false;
          this.isGlobe = false;
          this.renderer.stopLoop();
          this.video.pause();
          this.video.src = '';

          // Hide record button for images
          this.recordBtn.style.display = 'none';
          this.stopRecordBtn.style.display = 'none';

          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            this.placeholder.style.display = 'none';
            this._resizeContainerToSource(img.naturalWidth, img.naturalHeight);
            this.renderer.loadImage(img);
            URL.revokeObjectURL(url);
          };
          img.src = url;
        } else if (file.type.startsWith('video/')) {
          this.isVideo = true;
          this.isGlobe = false;
          this.video.src = url;
          this.video.onloadedmetadata = () => {
            this.placeholder.style.display = 'none';
            this._resizeContainerToSource(this.video.videoWidth, this.video.videoHeight);
            this.video.play();
            this.renderer.loadVideo();

            // Show record button for videos
            this.recordBtn.style.display = 'block';
          };
        }
      }

      _applyPreset(name) {
        const preset = this.presets[name];
        if (!preset) return;

        this.controls.cellSize.value = preset.cellSize;
        document.getElementById('cellSizeValue').textContent = preset.cellSize;
        this.renderer.updateCellSize(preset.cellSize);

        this.controls.gamma.value = preset.gamma;
        document.getElementById('gammaValue').textContent = preset.gamma;
        this.renderer.config.gamma = preset.gamma;

        this.controls.tileOpacity.value = preset.tileOpacity;
        document.getElementById('tileOpacityValue').textContent = preset.tileOpacity;
        this.renderer.config.tileOpacity = preset.tileOpacity;

        this.controls.glyphOpacity.value = preset.glyphOpacity;
        document.getElementById('glyphOpacityValue').textContent = preset.glyphOpacity;
        this.renderer.config.glyphOpacity = preset.glyphOpacity;

        this.controls.blendMode.value = preset.blendMode;
        this.renderer.config.blendMode = preset.blendMode;

        this.controls.blendStrength.value = preset.blendStrength;
        document.getElementById('blendStrengthValue').textContent = preset.blendStrength;
        this.renderer.config.blendStrength = preset.blendStrength;

        this.controls.density.value = preset.density;
        this.renderer.config.density = preset.density;
        this.renderer.rebuildAtlas();
      }

      _download() {
        if (!this.renderer._sourceReady) {
          alert('Please load an image or video first');
          return;
        }

        const canvas = document.getElementById('asciiCanvas');
        const link = document.createElement('a');
        link.download = `ascii-art-${canvas.width}x${canvas.height}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
      }
    }

    // Initialize
    window.addEventListener('DOMContentLoaded', () => {
      new ASCIIToolUI();
    });
  </script>
</body>
</html>
